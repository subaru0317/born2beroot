[aptitudeとaptの違い]
deb形式のパッケージ管理で利用できるのが、「apt」「apt-get」「aptitude」の3つ。
apt-get
	設計上のミスが存在する。現在はapt-cacheの機能を合わせたaptが使われている。
aptitude
	外部プロジェクトとして派生として誕生した。未完成。CUIに加えて、TUIを提供。
apt
	apt-getの設計上のミスを修正したもの。
	Debianで推奨されている。


[ディストリビューションとは？]
普段使用しているOSのような動きをするには、カーネルに加えて、コンパイラ、ライブラリ、シェル、インストーラなど様々なソフトウェアが必要となる。
これらのソフトウェアを集めてOSとして動作するようにして配布(distribute)されるソフトウエアをディストリビューションと呼ぶ。
言い換えると、カーネル、パッケージ管理、シェルなどの関連コンポーネントをまとめたものをディストリビューションと呼ぶ。
例）RedHat, Debianなど
また、OSの定義は曖昧であり、厳密には定まっていない。
Linuxとは厳密にはLinuxカーネルのみを指し、OSのことではない。

[OSおよびカーネルとは？]
OSの主な機能は、様々なハードウェアを抽象化してAPIを提供すること。
このAPIを使用してプログラミングすることによって、アプリケーションがどのようなハードウェア上で物理的にどのように実行されているかを隠蔽できる。
カーネルはこのようなAPIをプログラムに提供している。
カーネルはハードウェアとアプリケーションの間に位置する。
-主なコンポーネント-
・プロセス管理	：実行ファイルに基づくプロセスの起動など
・メモリ管理	：プロセスのメモリ割り当てや、ファイルをメモリにマップするなど
・ネットワーク	：ネットワークインターフェイスの管理、ネットワークスタックの提供など
・ファイルシステム：ファイル管理、ファイルの作成と削除など
・デバイスドライバ：デバイスの管理

[パッケージ管理とは？]
apt: 
	ソフトウェアを管理(インストール・削除など)する。
	インターネット上のリポジトリ(パッケージを保管・管理しているところ)を参照し、依存関係を含めて管理する。依存関係は自動解決される。
	現在利用しているOSのヴァージョンに合わせて、適切なヴァージョン、依存関係のあるパッケージも一緒にインストール・削除・アップデートをする。
	devパッケージを管理するユーティリティ。

[SELinuxとAppArmorの違い]
どちらも強制アクセス制御によるセキュリティの向上を行うプログラム。
・SELinux
	強制アクセス制御の実装として知られる。
	米国の政府機関の高いセキュリティ要件を満たすために開発された。
	このような経緯のため、ルールが厳しく、ユーザビリティが損なわれるため厳しいセキュリティが求められる環境で使用される。
	OS全体を制御しており、ディストリビューション内の情報のフローまでも管理する。包括的。
・AppArmor
	SELinuxより設定が容易。
	systemctlコマンドで現状確認を行うことができる。
	systemctl status apparmor.service
	個々のアプリケーションに焦点を当て、各アプリケーションが必要不可欠なライブラリやファイルのみにアクセスするよう制限する。

[RockyとDebianの違い]
「Debian」
・Debian Linuxから派生したディストリビューションをDebian系と呼ぶ
・deb形式のパッケージ管理を採用している。誰でも扱いやすい
・特定企業の支援を受けていない。個人の集団である「Debian Project」によって開発・運営が行われているフリーのLinux OS
簡単にソフトウェアの管理ができる高機能のパッケージ管理「APT」を搭載
50,000以上の豊富なパッケージ
Intel x86、ARM、IA-64など、多くのアーキテクチャをサポート
公式サポート体制が充実している
日本語にも対応
多くの派生ディストリビューションがある

「Rocky」
・RedHat社が開発したディストリビューションRedHad Linuxおよびその互換OSをRedHat系と呼ぶ
・rpm形式のパッケージ管理を採用している。
・商用Linuxの代表であり、多くの企業で利用されている。
・Rocky LinuxはCent OSの後継の一つであり、RedHat系である。Cent OS8からの移行をサポートしている
・RHEL(RedHat Enterprise Linux)との完全互換のLinuxディストリビューション
RHELおよびCentOSと1対1のバイナリ互換OS。バグ含め、全く同じように扱える
コミュニティを中心として開発される無償のOS
CentOSと同等のパッケージ提供速度

[VMとは？またどのようにして動作しているか]
物理マシン上にインストールしたOS上に、さらに別のOSをインストールする仮想マシン。
物理マシンの上に存在する仮想化ソフトウェア(今回では、VirtualBox)が仮想マシンを生成・管理・破棄を行う。
仮想マシン上ではカーネルが存在し、その上ではプロセスが実行されている。
物理マシン上のOS：ホストOS
仮想マシン上のOS：ゲストOS


[sudoの価値とその操作]
・セキュリティの観点からrootでの実行は可能な限り避けるべきである何かをインストールする必要があるときはrootでのログイン中にインストールするのではなく、
　sudoを使用するべき。
・su -コマンででrootアカウントに変更することはできる。しかし、これはrootのパスワードを知っていることが前提であり、また
　全ての管理者権限を利用できてしまうため、代わりにsudoを使う
・sudoは管理者権限を持たないユーザが管理者権限が必要な特定のコマンドを実行するために付加する
・ユーザごとに実行可能なコマンドを細かく制御できる。
・rootパスワードの入力が不要。代わりにユーザ自身のパスワードを入力する
・/etc/sudoersファイルを参照して、ユーザがコマンドの実行権限を持っているかを判定する。
・sudoコマンドを使用するとログとして記録される。/var/log/sudo/sudo.log
・rootユーザの実行は一般的に監視されないため、ログが残らない
　一方で、sudoコマンドの操作は監視されており、ログとして記録が残る。これによって、誰がどのコマンドを実行したかの追跡に役立つ

「/etc/sudoersファイルの書式」
ユーザ名　ホスト名=(実効ユーザ名) コマンド
%グループ名　ホスト名=(実効ユーザ名) コマンド
※このファイルは一般ユーザは編集できないため、rootで作業を行う
このファイルはvisudoコマンドによる編集が推奨されている。
ex)
root 	ALL=(ALL) ALL	# rootは全てのホスト上で管理者権限が必要なコマンドを管理者権限で実行できる
%wheel	ALL=(ALL) ALL	# wheelグループに属するユーザは、全てのホスト上で、管理者権限が必要なコマンドをユーザ権限で実行できる
yuko	centos7-1.localdomain=(root) /bin/head /etc/shadow


セキュリティ上の理由から、sudoが使用できるパスを制限する
・ /bin				: 基本コマンドが置かれているディレクトリ。boot時に必要なシステムの基本コマンドを置く。
・ /usr/bin			: 基本コマンドが置かれているディレクトリ。一般ユーザ向けの基本コマンドを置く。
					　ディストリビューションが管理するディレクトリであるため、自分が別途インストールするコマンドは/usr/local/binに置く。
・ /usr/local/bin	: 基本コマンドが置かれているディレクトリ。自分でパッケージシステム外でインストールする基本コマンドを置く。
・ /sbin			: 管理者用コマンドが置かれているディレクトリ。boot時に必要な管理者コマンドを置く。
・ /usr/sbin		: 管理者用コマンドが置かれているディレクトリ。平常時用のシステム管理コマンドやサーバプログラムを置く。
・ /usr/local/sbin	: 管理者用コマンドが置かれているディレクトリ。自分でパッケージシステム外でインストールする管理者用コマンドを置く。
・ /snap/bin		: DebianベースのディストリビューションではSnapがこのディレクトリにインストールされることがある。
					　Snapとは？
						ほぼ全ての主要なLinuxディストリビューションで実行可能。
						Linuxへのソフトウェアのインストールを容易にする
						具体的には、aptなどのツールでインストールする時の依存関係に関する問題を解決するパッケージマネージャ。
						似たものにflatpakなどが存在する

[パーティションとは？]
Linuxでディスク容量が不足すると、全体的なシステムに不具合が生じる。
	-> 解決策１：容量が足りなくなる前にディスク容量を追加する
	-> 解決策２：ディレクトリごとに別々のパーティションを割り当てる
解決策２について解説する。
パーティション(ディスク内の区画)を割り当てることによって、Aが容量不足になっても、Bは容量不足にならないのだ。
したがって、容量が肥大化しやすい箇所と稼働に関する重要なファイルを別のパーティションに分けたりする。

/boot	:	システム起動に関連するファイルを格納。システム起動時に最初に読み込むパーティション。
			ブートローダとカーネルイメージが保存されている。
			暗号化してはならない。暗号化されていると、利用できなくなり、システムが起動できなくなる。
			システム起動時にしか利用しない。運用時に利用するファイルとは別のパーティションを割り当てることが推奨される。
/home	:	ユーザの作業用ディレクトリ(ホームディレクトリ)
			複数のユーザが使用する可能性あり。使用量が大きくなる可能性が高いため、別のパーティションを割り当てることが推奨される。
/var	:	常に内容が書き換わるファイルを格納する。
			ログ、データの一時保存、Webサーバのコンテンツなどhomeディレクトリより肥大化しやすい。
			普通、別のパーティションを割り当てるべきである。
[SWAP]	:	メモリ不足になった際にメモリの空き容量を作るためのデータ退避エリア。
/tmp	:	長期保存の必要のないデータを保存するために使用される。

/dev/sda:	基本的にインストールしているストレージに割り当てられるデバイスファイル名。

[LVMの機能および概要]
パーティションで分割できることはわかった。しかし、容量不足に陥ったディレクトリはどうすれば良いのか。。。
LVMがなかったら、容量がより大きいパーティションを別途用意して全て移す。元のパーティションは削除する。という作業が必要になる。
LVM(Logical Volume Manager)という仕組みを使おう。ストレージを柔軟に管理することができる！
	->構築後に自由にサイズ変更できる点がGood！
LVMとは、複数のハードディスクやパーティションにまたがった記憶容量をまとめて、単一の論理ボリューム(LV)として扱えるディスク管理機能のこと。
1. HDDなどのストレージ内を物理的な区画(物理ボリューム)に分ける
2. 物理ボリュームをいくつか束ねて論理的なストレージとなる「ボリュームグループ」を作成する
3. ボリュームグループから必要な容量だけを「論理ボリューム」に割り当てる(この論理ボリュームはパーティションと同様に扱える)
ボリュームグループや論理ボリュームの容量の増減は簡単。
1. 容量を増やしたい
	ボリュームグループに物理ボリュームを追加する。
	増えたボリュームグループから必要な容量だけを論理ボリュームに割り当てる。
2. 容量を減らしたい
	論理ボリュームからボリュームグループに容量を戻す。

フィジカルエクステント	 : PE
	LVMが扱う最小単位。デフォルトで4MB。PEの最大数は65536個。
物理ボリューム			: PV
ボリュームグループ	 	 : VG
論理ボリューム			 : LV

$ sudo pvdisplay : PVを確認できる
$ sudo vgdisplay : VGを確認できる
$ sudo lvdisplay : LVを確認できる

加えて、「スナップショット」という便利機能が存在する。
「論理ボリューム」を瞬時にバックアップできる機能。

[UFWの機能および概要]
uncomplicated FireWall.
訳は、単純なファイアウォール。
LinuxのNetfilterによるファイアウォールを管理して操作するための"iptablesをラッパーした機能"のことを指す。
Linuxにはパケットフィルタリング(ファイアウォール)やNATを実現するためのNetfilterという機能を標準で備えている。
これを、操作・管理するためのツールとして、iptablesが存在する。
しかし、iptablesは設定が難しい。これを簡略化し、最低限のセキュリティ対策を行えるようにするのがUFW。
iptables
	Linuxに実装されているパケットフィルタリング型(入ってきたパケットのアクセス制御を行う)のfirewallの機能

$ ufw enable			# ファイアウォールの有効化
$ ufw unable			# ファイアウォールの無効化
$ ufw status numbered	# 状況確認(numberedは番号が割り振られるようになるオプション)
$ ufw allow xxx			# xxxサービスのアクセスを許可
$ ufw allow [num]		# TCP/UDP Port numでのアクセスを許可
$ ufw delete [num]		# num番目のルールを削除
その他、man ufwで確認可能


[SSHの機能および概要]
Secure SHellの略称。
安全ではないネットワーク上に置いて、暗号化されたネットワークプロトコルで安全なネットワークサービスを提供する。


[chageとは？]
有効期限の制御を行う。
chage -l [ユーザ名]
-l: 一覧表示するためのオプション

Last password change	: 最後にパスワードを変更した日付
Password expires		: パスワードの有効期限
Password inactive		: パスワードの有効期限が過ぎてからアカウントがロックされる期間(放置期間)
Account expires			: アカウントの有効期限
Minimum ~				: パスワードを変更する間隔の最小日数(この日数が経過しないと新しいパスワードの設定ができない)
Maximum ~				: パスワードを変更しなければならない間隔の最大日数(この日数でPassword expiresが決定する)
Number ~				: パスワードが期限切れになるまでの警告日数

$ sudo nano /etc/login.defs
でこれらの項目を設定することができる。

[monitoring.shの解説]
#!/bin/bash

wall $'#Architecture: ' `hostnamectl | grep "Operating System" | cut -d ' ' -f 5- ` `awk -F':' '/^model name/ {print $2}' /proc/cpuinfo | uniq | sed -e 's/^[ \t]*//'` `arch` \
wall		: 現在ログインしている全てのユーザの端末に標準入力の内容を表示する。
hostnamectl	: 
	Linuxシステム上でホスト名と関連するシステム情報を管理するためのコマンド。
	Static hostname	: システムの静的なホスト名を示す。ホスト名は通常、ネットワーク上で識別するための名前。
	Icon name		: デバイスやシステムのアイコンに関連する名前。通常、デスクトップ環境で使用される。
	Chassis			: システムの筐体タイプを示す。ラップトップ、デスクトップ、サーバなど。
	Machine ID		: システムの一意の識別子で、ランダムに生成される。システムの再インストールなどに関係する。
	Boot ID			: システムのブートセッションごとに生成される一意の識別子。システムの起動ごとに異なる値となる。
	Virtualization	: システムが仮想化環境内で動作している場合、その仮想化プラットフォームの情報を示す。
	Operating System: インストールされているOSの名称を示す。
	Kernel			: 現在実行中のカーネルのバージョンを示す。カーネルはOSの中核であり、ハードウェアとソフトウェアのインターフェースを提供する。
	Architecture	: システムのプロセッサアーキテクチャを示す。x86_64、arm、ppcなど。
grep "Operating System"
	Operating Systemの業を取得。
cut -d ' ' -f 5- 
	-d delim
		フィールドの区切り文字(delimiter)を指定する。(ここではスペース)
	-f list
		抽出するフィールドの範囲を指定する。(5- は5番目以降)


$'\n#CPU physical: '`cat /proc/cpuinfo | grep processor | wc -l` \
$'\n#vCPU:  '`cat /proc/cpuinfo | grep processor | wc -l` \
$'\n'`free -m | awk 'NR==2{printf "#Memory Usage: %s/%sMB (%.2f%%)", $3,$2,$3*100/$2 }'` \
$'\n'`df -h | awk '$NF=="/"{printf "#Disk Usage: %d/%dGB (%s)", $3,$2,$5}'` \
$'\n'`top -bn1 | grep load | awk '{printf "#CPU Load: %.2f\n", $(NF-2)}'` \
$'\n#Last boot: ' `who -b | awk '{print $3" "$4" "$5}'` \
$'\n#LVM use: ' `lsblk |grep lvm | awk '{if ($1) {print "yes";exit;} else {print "no"} }'` \
$'\n#Connection TCP:' `netstat -an | grep ESTABLISHED |  wc -l` \
$'\n#User log: ' `who | cut -d " " -f 1 | sort -u | wc -l` \
$'\nNetwork: IP ' `hostname -I`"("`ip a | grep link/ether | awk '{print $2}'`")" \
$'\n#Sudo:  ' `grep 'sudo ' /var/log/auth.log | wc -l`

[ttyとは？]
UNIXでは端末のことをttyと呼ぶ。

[hostnameとは？]
インターネットではコンピュータという名称の代わりに”ホスト”または”ノード”という用語を使う。
ローカルで特定のファイルに書き込みなどを行いたいときは、パスを指定して、ストリームを作成する。ネットワークでも本質は変わらない。
インターネットにおいて、ファイルシステムでのファイル名に相当するのは”IPアドレス”と"Port番号"。
IPアドレス	: 符号なし32bitの数値。ex) 192.168.1.3
Port番号	: 0~65535の数値。ホスト1台を1つの駅とすると、ポート番号は駅の番線のようなもの。
			　1つの駅でも何本もの列車が行き来できるように、1つのIPアドレスでいくつもの回線が繋げられる。

ネットワーク上ではホストはIPアドレスで識別される。しかし、IPアドレスは単なる番号であり、人間にとっては不便。
ここで、IPアドレスの代わりに”ホスト名(hostname)”を使っている。
ex) www.linux.com
ex) www.linux.or.jp
/etc/hostsファイルにIPアドレスとホスト名の対応表が存在する。
(現在では、基本的にDNSが対応している。しかし、小さなネットワーク(会社・家庭など)では使われている)


[wall, cron]