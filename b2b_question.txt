[aptitudeとaptの違い]
deb形式のパッケージ管理で利用できるのが、「apt」「apt-get」「aptitude」の3つ。
apt-get
	設計上のミスが存在する。現在はapt-cacheの機能を合わせたaptが使われている。
aptitude
	外部プロジェクトとして派生として誕生した。未完成。CUIに加えて、TUIを提供。
apt
	apt-getの設計上のミスを修正したもの。
	Debianで推奨されている。


[ディストリビューションとは？]
普段使用しているOSのような動きをするには、カーネルに加えて、コンパイラ、ライブラリ、シェル、インストーラなど様々なソフトウェアが必要となる。
これらのソフトウェアを集めてOSとして動作するようにして配布(distribute)されるソフトウエアをディストリビューションと呼ぶ。
言い換えると、カーネル、パッケージ管理、シェルなどの関連コンポーネントをまとめたものをディストリビューションと呼ぶ。
例）RedHat, Debianなど
また、OSの定義は曖昧であり、厳密には定まっていない。
Linuxとは厳密にはLinuxカーネルのみを指し、OSのことではない。

[OSおよびカーネルとは？]
OSの主な機能は、様々なハードウェアを抽象化してAPIを提供すること。
このAPIを使用してプログラミングすることによって、アプリケーションがどのようなハードウェア上で物理的にどのように実行されているかを隠蔽できる。
カーネルはこのようなAPIをプログラムに提供している。
カーネルはハードウェアとアプリケーションの間に位置する。
-主なコンポーネント-
・プロセス管理	：実行ファイルに基づくプロセスの起動など
・メモリ管理	：プロセスのメモリ割り当てや、ファイルをメモリにマップするなど
・ネットワーク	：ネットワークインターフェイスの管理、ネットワークスタックの提供など
・ファイルシステム：ファイル管理、ファイルの作成と削除など
・デバイスドライバ：デバイスの管理

[パッケージ管理とは？]
apt: 
	ソフトウェアを管理(インストール・削除など)する。
	インターネット上のリポジトリ(パッケージを保管・管理しているところ)を参照し、依存関係を含めて管理する。依存関係は自動解決される。
	現在利用しているOSのヴァージョンに合わせて、適切なヴァージョン、依存関係のあるパッケージも一緒にインストール・削除・アップデートをする。
	devパッケージを管理するユーティリティ。

[SELinuxとAppArmorの違い]
どちらも強制アクセス制御によるセキュリティの向上を行うプログラム。
・SELinux
	強制アクセス制御の実装として知られる。
	米国の政府機関の高いセキュリティ要件を満たすために開発された。
	このような経緯のため、ルールが厳しく、ユーザビリティが損なわれるため厳しいセキュリティが求められる環境で使用される。
	OS全体を制御しており、ディストリビューション内の情報のフローまでも管理する。包括的。
・AppArmor
	SELinuxより設定が容易。
	systemctlコマンドで現状確認を行うことができる。
	systemctl status apparmor.service
	個々のアプリケーションに焦点を当て、各アプリケーションが必要不可欠なライブラリやファイルのみにアクセスするよう制限する。

[RockyとDebianの違い]
「Debian」
・Debian Linuxから派生したディストリビューションをDebian系と呼ぶ
・deb形式のパッケージ管理を採用している。誰でも扱いやすい
・特定企業の支援を受けていない。個人の集団である「Debian Project」によって開発・運営が行われているフリーのLinux OS
簡単にソフトウェアの管理ができる高機能のパッケージ管理「APT」を搭載
50,000以上の豊富なパッケージ
Intel x86、ARM、IA-64など、多くのアーキテクチャをサポート
公式サポート体制が充実している
日本語にも対応
多くの派生ディストリビューションがある

「Rocky」
・RedHat社が開発したディストリビューションRedHad Linuxおよびその互換OSをRedHat系と呼ぶ
・rpm形式のパッケージ管理を採用している。
・商用Linuxの代表であり、多くの企業で利用されている。
・Rocky LinuxはCent OSの後継の一つであり、RedHat系である。Cent OS8からの移行をサポートしている
・RHEL(RedHat Enterprise Linux)との完全互換のLinuxディストリビューション
RHELおよびCentOSと1対1のバイナリ互換OS。バグ含め、全く同じように扱える
コミュニティを中心として開発される無償のOS
CentOSと同等のパッケージ提供速度

[VMとは？またどのようにして動作しているか]
物理マシン上にインストールしたOS上に、さらに別のOSをインストールする仮想マシン。
物理マシンの上に存在する仮想化ソフトウェア(今回では、VirtualBox)が仮想マシンを生成・管理・破棄を行う。
仮想マシン上ではカーネルが存在し、その上ではプロセスが実行されている。
物理マシン上のOS：ホストOS
仮想マシン上のOS：ゲストOS


[sudoの価値とその操作]
・セキュリティの観点からrootでの実行は可能な限り避けるべきである何かをインストールする必要があるときはrootでのログイン中にインストールするのではなく、
　sudoを使用するべき。
・su -コマンででrootアカウントに変更することはできる。しかし、これはrootのパスワードを知っていることが前提であり、また
　全ての管理者権限を利用できてしまうため、代わりにsudoを使う
・sudoは管理者権限を持たないユーザが管理者権限が必要な特定のコマンドを実行するために付加する
・ユーザごとに実行可能なコマンドを細かく制御できる。
・rootパスワードの入力が不要。代わりにユーザ自身のパスワードを入力する
・/etc/sudoersファイルを参照して、ユーザがコマンドの実行権限を持っているかを判定する。
・sudoコマンドを使用するとログとして記録される。/var/log/sudo/sudo.log
・rootユーザの実行は一般的に監視されないため、ログが残らない
　一方で、sudoコマンドの操作は監視されており、ログとして記録が残る。これによって、誰がどのコマンドを実行したかの追跡に役立つ

「/etc/sudoersファイルの書式」
ユーザ名　ホスト名=(実効ユーザ名) コマンド
%グループ名　ホスト名=(実効ユーザ名) コマンド
※このファイルは一般ユーザは編集できないため、rootで作業を行う
このファイルはvisudoコマンドによる編集が推奨されている。
ex)
root 	ALL=(ALL) ALL	# rootは全てのホスト上で管理者権限が必要なコマンドを管理者権限で実行できる
%wheel	ALL=(ALL) ALL	# wheelグループに属するユーザは、全てのホスト上で、管理者権限が必要なコマンドをユーザ権限で実行できる
yuko	centos7-1.localdomain=(root) /bin/head /etc/shadow


セキュリティ上の理由から、sudoが使用できるパスを制限する
・ /bin				: 基本コマンドが置かれているディレクトリ。boot時に必要なシステムの基本コマンドを置く。
・ /usr/bin			: 基本コマンドが置かれているディレクトリ。一般ユーザ向けの基本コマンドを置く。
					　ディストリビューションが管理するディレクトリであるため、自分が別途インストールするコマンドは/usr/local/binに置く。
・ /usr/local/bin	: 基本コマンドが置かれているディレクトリ。自分でパッケージシステム外でインストールする基本コマンドを置く。
・ /sbin			: 管理者用コマンドが置かれているディレクトリ。boot時に必要な管理者コマンドを置く。
・ /usr/sbin		: 管理者用コマンドが置かれているディレクトリ。平常時用のシステム管理コマンドやサーバプログラムを置く。
・ /usr/local/sbin	: 管理者用コマンドが置かれているディレクトリ。自分でパッケージシステム外でインストールする管理者用コマンドを置く。
・ /snap/bin		: DebianベースのディストリビューションではSnapがこのディレクトリにインストールされることがある。
					　Snapとは？
						ほぼ全ての主要なLinuxディストリビューションで実行可能。
						Linuxへのソフトウェアのインストールを容易にする
						具体的には、aptなどのツールでインストールする時の依存関係に関する問題を解決するパッケージマネージャ。
						似たものにflatpakなどが存在する

[パーティションとは？]
Linuxでディスク容量が不足すると、全体的なシステムに不具合が生じる。
	-> 解決策１：容量が足りなくなる前にディスク容量を追加する
	-> 解決策２：ディレクトリごとに別々のパーティションを割り当てる
解決策２について解説する。
パーティション(ディスク内の区画)を割り当てることによって、Aが容量不足になっても、Bは容量不足にならないのだ。
したがって、容量が肥大化しやすい箇所と稼働に関する重要なファイルを別のパーティションに分けたりする。

/boot	:	システム起動に関連するファイルを格納。システム起動時に最初に読み込むパーティション。
			ブートローダとカーネルイメージが保存されている。
			暗号化してはならない。暗号化されていると、利用できなくなり、システムが起動できなくなる。
			システム起動時にしか利用しない。運用時に利用するファイルとは別のパーティションを割り当てることが推奨される。
/home	:	ユーザの作業用ディレクトリ(ホームディレクトリ)
			複数のユーザが使用する可能性あり。使用量が大きくなる可能性が高いため、別のパーティションを割り当てることが推奨される。
/var	:	常に内容が書き換わるファイルを格納する。
			ログ、データの一時保存、Webサーバのコンテンツなどhomeディレクトリより肥大化しやすい。
			普通、別のパーティションを割り当てるべきである。
[SWAP]	:	メモリ不足になった際にメモリの空き容量を作るためのデータ退避エリア。
/tmp	:	長期保存の必要のないデータを保存するために使用される。
				誰でも読み書き可能な共有データを配置．
				一般ユーザの利用の仕方による危険性を考慮し，独立したパーティションにする場合が多い．
/			: ルートディレクトリが格納される領域
/dev/sda:	基本的にインストールしているストレージに割り当てられるデバイスファイル名。

[LVMの機能および概要]
パーティションで分割できることはわかった。しかし、容量不足に陥ったディレクトリはどうすれば良いのか。。。
LVMがなかったら、容量がより大きいパーティションを別途用意して全て移す。元のパーティションは削除する。という作業が必要になる。
LVM(Logical Volume Manager)という仕組みを使おう。ストレージを柔軟に管理することができる！
	->構築後に自由にサイズ変更できる点がGood！
LVMとは、複数のハードディスクやパーティションにまたがった記憶容量をまとめて、単一の論理ボリューム(LV)として扱えるディスク管理機能のこと。
1. HDDなどのストレージ内を物理的な区画(物理ボリューム)に分ける
2. 物理ボリュームをいくつか束ねて論理的なストレージとなる「ボリュームグループ」を作成する
3. ボリュームグループから必要な容量だけを「論理ボリューム」に割り当てる(この論理ボリュームはパーティションと同様に扱える)
ボリュームグループや論理ボリュームの容量の増減は簡単。
1. 容量を増やしたい
	ボリュームグループに物理ボリュームを追加する。
	増えたボリュームグループから必要な容量だけを論理ボリュームに割り当てる。
2. 容量を減らしたい
	論理ボリュームからボリュームグループに容量を戻す。

フィジカルエクステント	 : PE
	LVMが扱う最小単位。デフォルトで4MB。PEの最大数は65536個。
物理ボリューム			: PV
ボリュームグループ	 	 : VG
論理ボリューム			 : LV

$ sudo pvdisplay : PVを確認できる
$ sudo vgdisplay : VGを確認できる
$ sudo lvdisplay : LVを確認できる

加えて、「スナップショット」という便利機能が存在する。
「論理ボリューム」を瞬時にバックアップできる機能。

[UFWの機能および概要]
uncomplicated FireWall.
訳は、単純なファイアウォール。
LinuxのNetfilterによるファイアウォールを管理して操作するための"iptablesをラッパーした機能"のことを指す。
Linuxにはパケットフィルタリング(ファイアウォール)やNATを実現するためのNetfilterという機能を標準で備えている。
これを、操作・管理するためのツールとして、iptablesが存在する。
しかし、iptablesは設定が難しい。これを簡略化し、最低限のセキュリティ対策を行えるようにするのがUFW。
iptables
	Linuxに実装されているパケットフィルタリング型(入ってきたパケットのアクセス制御を行う)のfirewallの機能

$ ufw enable			# ファイアウォールの有効化
$ ufw unable			# ファイアウォールの無効化
$ ufw status numbered	# 状況確認(numberedは番号が割り振られるようになるオプション)
$ ufw allow xxx			# xxxサービスのアクセスを許可
$ ufw allow [num]		# TCP/UDP Port numでのアクセスを許可
$ ufw delete [num]		# num番目のルールを削除
その他、man ufwで確認可能


[SSHの機能および概要]
Secure SHellの略称。
安全ではないネットワーク上に置いて、暗号化されたネットワークプロトコルで安全なネットワークサービスを提供する。


[chageとは？]
有効期限の制御を行う。
chage -l [ユーザ名]
-l: 一覧表示するためのオプション

Last password change	: 最後にパスワードを変更した日付
Password expires		: パスワードの有効期限
Password inactive		: パスワードの有効期限が過ぎてからアカウントがロックされる期間(放置期間)
Account expires			: アカウントの有効期限
Minimum ~				: パスワードを変更する間隔の最小日数(この日数が経過しないと新しいパスワードの設定ができない)
Maximum ~				: パスワードを変更しなければならない間隔の最大日数(この日数でPassword expiresが決定する)
Number ~				: パスワードが期限切れになるまでの警告日数

$ sudo nano /etc/login.defs
でこれらの項目を設定することができる。

[monitoring.shの解説]
#!/bin/bash

wall $'#Architecture: ' `hostnamectl | awk '/Kernel/ {print $2 $3}'` `hostnamectl | awk '/Operating System/ {for (i=3;i<=NF;i++) printf $i" "}` \
wall		: 現在ログインしている全てのユーザの端末に標準入力の内容を表示する。
hostnamectl	: 
	Linuxシステム上でホスト名と関連するシステム情報を管理するためのコマンド。
	Static hostname	: システムの静的なホスト名を示す。ホスト名は通常、ネットワーク上で識別するための名前。
	Icon name		: デバイスやシステムのアイコンに関連する名前。通常、デスクトップ環境で使用される。
	Chassis			: システムの筐体タイプを示す。ラップトップ、デスクトップ、サーバなど。
	Machine ID		: システムの一意の識別子で、ランダムに生成される。システムの再インストールなどに関係する。
	Boot ID			: システムのブートセッションごとに生成される一意の識別子。システムの起動ごとに異なる値となる。
	Virtualization	: システムが仮想化環境内で動作している場合、その仮想化プラットフォームの情報を示す。
	Operating System: インストールされているOSの名称を示す。
	Kernel			: 現在実行中のカーネルのバージョンを示す。カーネルはOSの中核であり、ハードウェアとソフトウェアのインターフェースを提供する。
	Architecture	: システムのプロセッサアーキテクチャを示す。x86_64、arm、ppcなど。
for (i=3;i<=NF;i++) printf $i" "
	3番目以降をすべて出力
$'\n#CPU physical: '`cat /proc/cpuinfo | grep "physical\sid" | wc -l` \
/proc/cpuinfoについては下記に記載
"physical\sid"の\sは空白を示している．
$'\n#vCPU:  '`cat /proc/cpuinfo | grep processor | wc -l` \
processorに論理プロセッサの番号が書かれている．例えばプロセッサが0~3まであるとき，
processor: 0
processor: 1
processor: 2
processor: 3
のようになる．よって，wc -lで行数を取得することによってプロセッサの数を取得する．
$'\n'`free -m | awk 'NR==2{printf "#Memory Usage: %s/%sMB (%.2f%%)", $3,$2,$3*100/$2 }'` \
freeコマンド：システム内のメモリの状況を確認することができる
	total 		 :	合計メモリ量
	used  		 :	メモリ使用量(実際にプロセスで使用されているメモリ量)
	free  		 :	全く使われていない未割り当てのメモリ量
	shared		 :	共有メモリで使用しているメモリ量
	buff/cache :	ファイルバッファ + キャッシュメモリに使われているメモリ量
	available	 :	プロセスが利用できるメモリ量

	Mem		:	物理メモリ
	Swap	: スワップメモリ
						LinuxではSwapというパーティションが一般的には作成される．
						これは，ハードディスク上に作成する仮想的なメモリ領域.
						(ストレージデバイスをメモリの代わりに使用ということ　)
						Linuxを使用していて実メモリが不足した場合，ハードディスクに
						作成されたスワップ領域(仮想メモリ)が使用される						
						プログラムの未使用ページ(固定サイズの小さなサイズのこと)がスワップ領域におかれる．
						必要になったら物理メモリへロードされる．
				　共有メモリ
				　　特定範囲の物理メモリを複数プロセスで共有する機構のこと．(他のプロセスからも参照可能となる)
						「プロセスごとにメモリが分けられているから安全」というのは基本だが，
						同じメモリを共有できた方が便利な場合がある．
						具体例として，巨大な画像データを複数プロセスで編集するときがあげられる
						画像データをおいたメモリを共有メモリとして扱う．
						ユーザメモリ，カーネルメモリ間のデータ転送，システムコールなどが不要となるため，
						共有メモリは高速な通信手段である．

-m オプション
	メモリ量をメガバイト単位で表示する．
NR == 2
今回必要なのはRAM(物理メモリ)なので，Memだけが必要．
ストレージデバイスであるSwapは不必要．
従って，出力結果のMemだけを取得する．
{printf ...}
total: 合計メモリ量と used: メモリ使用量を取り出して，出力する．


$'\n'`df -h | awk '$NF=="/"{printf "#Disk Usage: %d/%dGB (%s)", $3,$2,$5}'` \
df: ファイルシステムのディスク容量の使用状況を表示する
	ファイル名を指定しない - 現在マウントしているすべてのファイルシステムの空きディスク容量を表示する
	マウント --- コンピュータ上で利用可能なストレージデバイスやリモートファイルシステムなど、
							ファイルとデータを格納するためのディスク領域を表す
-h オプション
人が読みやすい形式で表示する
awk '$NF=="/"
Mounted onの"/"を表す．NFはフィールド数を意味するため，$NFは一番最後のフィールドを指す．
/dev：このディレクトリは、Linuxシステム上のデバイスファイルが格納されているディレクトリです。
			デバイスファイルは物理的なハードウェアデバイスや論理的なデバイスにアクセスするための仮想ファイルです。

/mapper：これはLVM（Logical Volume Manager）によって提供されるデバイスの仮想的なパスです。
					LVMは、物理ボリューム（Physical Volume）から論理ボリューム（Logical Volume）を作成し、管理するためのボリューム管理ツールです。

smihata--vg-root：
これはLVMで作成された論理ボリュームの名前です。
smihata--vgはボリュームグループ（Volume Group）の名前であり、
rootはこの論理ボリュームの名前です。
この論理ボリュームは通常、Linuxシステムのルートファイルシステム（/）
として使用されます．

$'\n'`top -bn1 | grep load | awk '{printf "#CPU Load: %.2f\n", $(NF-2)}'` \
top: Linuxの稼働中のシステムの動的なリアルタイムのタスクを表示する
-b: バッチモードで実行する．
バッチモードでは、topは対話的なユーザーインタラクションを必要とせず，単一の出力を生成します。

-n1: topが情報を更新する回数を指定する。
-n1は、topが1回だけ情報を表示して終了することを意味します。
topがリアルタイムの情報を表示せずに、単一の瞬間のスナップショットを生成します．


$'\n#Last boot: ' `who -b | awk '{print $3" "$4" "$5}'` \
$'\n#LVM use: ' `lsblk |grep lvm | awk '{if ($1) {print "yes";exit;} else {print "no"} }'` \
$'\n#Connection TCP:' `netstat -an | grep ESTABLISHED |  wc -l` \
$'\n#User log: ' `who | cut -d " " -f 1 | sort -u | wc -l` \
$'\nNetwork: IP ' `hostname -I`"("`ip a | grep link/ether | awk '{print $2}'`")" \
$'\n#Sudo:  ' `grep 'sudo ' /var/log/auth.log | wc -l`

/proc/cpuinfo:
	processor					: 論理プロセッサの番号を示す．
	vendor_id					: プロセッサの製造元を示す．ex) GenuineIntel, AuthenticAMDなど
	cpu family				: プロセッサファミリーの番号を示す．
											同じアーキテクチャや設計思想に基づいて開発された一連のプロセッサモデルのグループを指す．
											ex) Intel Coreシリーズ，ARM Cortexシリーズなど
	model							: プロセッサモデルの番号を示す．
											プロセッサファミリ内での個々の製品やバリエーションを指す．
											ex) Intel Core i7-8700K
	model name				: プロセッサのモデル名を示す．
											特定のプロセッサ製品を識別するための名称
	stepping					: プロセッサのステップ番号を示す．
											プロセッサの製造工程やリビジョンのバージョンを識別するための番号．
											プロセッサは製造過程で改良や修正がしばしば行われる．それぞれに番号が振られる．
	microcode					: プロセッサのマイクロコードのバージョンや更新情報を示す．
											マイクロコード：プロセッサの動作やセキュリティの改善を行うために定期的に更新される．
	cpu MHz						: プロセッサのクロック周波数をメガヘルツで示す．
	cache size				: プロセッサの各レベルのキャッシュサイズを示す．
											キャッシュとは高速なメモリのこと．
											キャッシュは階層的な構造を持つ．L1キャッシュ，L2キャッシュ．．．などとあり，容量と速度がトレードオフとなっている．
	physical id				: 論理プロセッサが属する物理的なプロセッサ(ソケット)の識別子を示す．
	siblings					: 同じ物理プロセッサ上での同時実行可能なスレッド数を示す．
	core id						: マルチコアプロセッサが複数の物理コアを持つ場合，各論理プロセッサ(スレッド)がどの物理コアに属しているかを示す識別子．
	cpu cores					: 物理コア数を示す．
	apicid						: APIC(Advanced Programmable Interrupt Controller)に関連する識別子．プロセッサがシステム内で一意に識別されるために使用される．
											APICは，複数のプロセッサやデバイス間に割り込みを管理し，制御するための高度な制御装置．
	initial apicid		: ブートプロセッサ(最初に起動するプロセッサ)のAPIC識別子を示す．
	fpu								: 浮動小数点ユニット(FPU)の有無を示す．FPUは浮動小数点をサポートするユニットであり，数値計算や科学技術計算などで用いられる．
	fpu_exception			: 浮動小数点例外が有効か無効かを示す．計算中に発生する数値のオーバーフローやアンダーフロー，ゼロ除算などの特殊条件を処理するためのもの．
	cpuid level				: CPUID命令のレベルを示す．プロセッサの特性や機能に関する情報を取得するための命令．
	wp								: Write Protectビットの有無を示す．一部のプロセッサでメモリ領域を読取り専用または書き込み可能に設定するための機能．
	flags							: プロセッサのサポートをする特殊機能を示す．
	bugs							: プロセッサのバグや制約条件に関連する情報を示す．
	bogomips					: システムのボゴマイプス値を示す(ベンチマーク単位)
	TLB size					: Translation Lookaside Bufferのサイズを示す．
											TLBは仮想アドレスと物理アドレスの対応を保持するキャッシュであり，メモリあくせすの拘束かに寄与します．
	clflush size			: キャッシュラインのフラッシュ(無効化)のサイズを示す．キャッシュラインは，メモリアクセスの最小単位．データをキャッシュからメモリに戻す際のフラッシュするサイズ．
											単位はByte．プロセッサ内のキャッシュはこのサイズの塊単位でデータを扱う．
	cache_alignment		: キャッシュのアライメント(配置)サイズを示す．アライメントは，データや命令がキャッシュ内でどのように配置されるかを指定する．
	address sizes			: アドレスサイズに関連する情報を示す．32bit architectureでは32bit, 64bit architectureでは64bitのアドレス空間がサポートされている．
	power management	: 電力管理に関する情報を示す．プロセッサの省エネ機能やクロック周波数の変更など，電力消費を調整する機能に関連する情報が含まれる．


[ttyとは？]
UNIXでは端末のことをttyと呼ぶ。

[hostnameとは？]
インターネットではコンピュータという名称の代わりに”ホスト”または”ノード”という用語を使う。
ローカルで特定のファイルに書き込みなどを行いたいときは、パスを指定して、ストリームを作成する。ネットワークでも本質は変わらない。
インターネットにおいて、ファイルシステムでのファイル名に相当するのは”IPアドレス”と"Port番号"。
IPアドレス	: 符号なし32bitの数値。ex) 192.168.1.3
Port番号	: 0~65535の数値。ホスト1台を1つの駅とすると、ポート番号は駅の番線のようなもの。
			　1つの駅でも何本もの列車が行き来できるように、1つのIPアドレスでいくつもの回線が繋げられる。

ネットワーク上ではホストはIPアドレスで識別される。しかし、IPアドレスは単なる番号であり、人間にとっては不便。
ここで、IPアドレスの代わりに”ホスト名(hostname)”を使っている。
ex) www.linux.com
ex) www.linux.or.jp
/etc/hostsファイルにIPアドレスとホスト名の対応表が存在する。
(現在では、基本的にDNSが対応している。しかし、小さなネットワーク(会社・家庭など)では使われている)


[wall]
現在ログインしているすべてのユーザに対してメッセージを書き込むコマンド．ブロードキャスト．
メッセージの受信を拒否する設定をしているユーザには管理者だけがメッセージを届けることができる．
-g [group]
このオプションによって特定のグループに限定してメッセージを送信することができる．


[cron]
crontabコマンド
	cronジョブの実行・変数・リスト・除去を行う．
cronジョブ
	cronデーモンによりスケジュールされ，一定の周期で実行されるジョブのこと．